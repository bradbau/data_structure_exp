1.图的数据结构使用有向图
    数据中不能含有两个相同的边，因为边集和节点集都是集合,要

2.
    两种声明那种好，把邻接表抽象成结构还是用底层的表节点表示表

3.节点的第一索引
    用顺序数字索引所有的点，那么这个索引从0开始，所以所有的内部通信全部从0开始
    把节点的序号当成他的第一索引是不合理的，因为在删除节点时，
    剩下的节点信息没有变，但是
    其索引却必须改变。这是不符合逻辑的。
    但是还有一个问题，如果我用独立于节点本身信息的值作为索引，
    连接节点的方式是依附于物理结构的；
    那么在删除某一个节点时，其物理结构的改变就会使节点的连接方式改变，这绝对是错误的
    以上两种方法看似不同，其实都依赖于节点的物理结构来构建联系，那么删除节点造成的物理结构
    就会迫使节点的连接域按照新的物理结构重新构建，这是非常低效的。
    
    改成直接保存指向节点的指针怎么样？只有在这个邻接表的数组存储的是节点指针
    时才不用改变其他的链表节点索引；他的缺点还有在想要人为指定操作对象时，还必须
    再次使用节点的关键词定位来获得地址

    改成保存节点的ID怎么样，其实这就是使用独立于物理结构的索引来建立图的结构
    只要能保证节点ID没有二义性就是最好的解决方法。
    但是这样每进行一次于节点定位有关的操作就要经历一个O(n)时间的操作，在效率上是不足的

4. 建树时的操作，不能按照图的信息来构造物理节点信息；不能用图来保存节点在数组内的序号

debug 
1. pFile = fopen(Fn, "r");
    这一句出了问题
        Thread 1 received signal SIGSEGV, Segmentation fault.
        0x00007ffccb0cc018 in ntdll!RtlSizeHeap () from C:\WINDOWS\SYSTEM32\ntdll.dll
    关键是在ntdll中的RtlSizeHeap () 它的返回值如下Success: The size of the block. Failure: -1, heap or pointer are invalid.
    所以可以确定这个问题是程序的大小错误（堆溢出）或者指针的指向（invalid pointer）问题。
    而这个问题的来源也很简单，要么是文件名参数的错误，要么是文件读取格式的错误。
    然而奇怪的是就在于当我把文件读写操作放在一个独立的函数中时，这个读取就可以正常进行了
    我也尝试了用data和txt后缀都是在别的文件中可以运行，这里不行。


2.第二次读入文件就会在插入弧的时候出现问题